# 第23章 持续集成

由Rachel Tannenbaum撰写，Lisa Carey编辑

*连续集成*（CI）通常被定义为”团队成员需要频繁集成他们工作的软件开发工作[...]每次集成都通过自动构建（包括测试）进行验证，以检测集成错误。“<sup>1</sup>简而言之，持续集成的基本目标是尽早自动发现有问题的代码更新。

“持续集成”对于现代的分布式应用有什么意义？当今的系统除了仓库中的最新版本代码外，还有许多其他不错的部分。实际上，随着微服务的最新趋势，破坏程序的代码更新不太可能存在于项目的当前仓库中，而更有可能出现在网络调用另一端的松耦合微服务中。传统的连续构建会测试二进制文件中的更新，在这上的扩展可能会测试上游微服务的更改。依赖关系只是从函数调用堆栈转移到HTTP请求或远程过程调用（RPC）。

即使远离代码依赖关系，程序也可能会定期提取数据或更新机器学习模型。它可能在不断发展的操作系统，内存管理，云托管服务和设备上执行。它可能是一个位于不断发展的平台之上的功能，也可能是必须适应不断增长的功能的基础平台。所有这些东西都应被视为依赖项，我们也应致力于“持续集成”它们的更新。更复杂的是，这些不断变化的模块通常由我们团队，组织或公司之外的开发人员拥有，并按自己的进度进行部署。

因此，对于当今的持续集成，尤其是在大规模开发时，可能有一个更好的定义：

> *持续集成（2）*：对我们整个复杂而迅速发展的系统环境的不断合并和测试。

从测试的角度对持续集成进行概念化是很自然的，因为两者紧密相关，我们将在本章中继续进行。在前面的章节中，我们讨论了从单元到集成，再到更大范围的系统的全面测试。

从测试方面来说，持续集成是一个介绍以下部分的范例：

• 在开发/发布开发过程中，随着代码（和其他部分）的更新的不断集成，要运行哪些测试

• 如何在每个测试点上组成被测系统（SUT），平衡准确性和启动成本等

例如，我们在提交前运行哪些测试，在提交后保存哪些测试，甚至在以后进行暂存部署之前保存哪些测试？因此，我们如何在这些测试点上划分我们的SUT？就像你想象的那样，预提交SUT的要求可能与测试中的过渡环境的要求有很大不同。例如，在代码审核前提交前的程序与真实的生产后端进行交互（可能存在安全性和配额漏洞问题）可能很危险，但对于过渡环境而言，这通常是可以接受的。

为何我们还要尝试通过持续集成在“合适的时间”测试“合适的事物”达成这一通常微妙的平衡呢？大量的先前工作已经建立了持续集成对开发团队和整个业务的好处。<sup>2</sup>这些结果是由有力的证据所驱动的：即时的可验证的程序可以很好地发展到下一个阶段。我们不需要只是希望所有贡献者都非常谨慎，负责和透彻；相反，我们可以保证从构建到发行的各个阶段，我们的应用程序都处于工作状态，从而提高了我们对产品的信心和质量以及团队的生产力。

在本章的其余部分中，我们将介绍一些关键的CI概念，最佳实践和挑战，然后介绍我们在Google上如何管理持续集成，并且将通过一个程序在持续集成转换上的深入研究来介绍我们的持续构建工具TAP。

## 持续集成概念

首先，让我们开始研究持续集成的一些核心概念。

## 快速反馈循环

正如第11章所讨论的，一个错误越晚被发现它所花费的成本会成倍的增加。图23-1展示了所有有问题的代码在时间线中可能被发现的时间节点。

![image-20210413195010773](/Users/xuhuan/Library/Application Support/typora-user-images/image-20210413195010773.png)

* 图23-1. 代码更新的时间线

通常来说，随着问题发展到图表的右边，它们被发现的所消耗的成本更多，主要因为以下原因：

- 它们肯定是由不熟悉代码更改的工程师对它们进行分类。
- 它们需要代码更新的坐着消耗更多的工作了来收集和调查代码更新。
- 它们会对他人产生负面影响，无论是工作中的工程师还是最终用户。

为了最大程度地减少错误的成本，持续集成鼓励我们使用*快速反馈循环。*<sup> 3</sup>每当我们将代码（或其他部分）更新集成到测试环境中并观察结果时，我们都会得到一个新的*反馈循环*。反馈可以采取多种形式，以下是一些常见的（从最快到最慢的顺序排列）：

- 本地开发的编写-编译-调试循环
- 代码更新作者在提交前的自动化测试结果
- 在两个项目的更新一起提交并测试后检测到的两个项目的更新之间的集成错误（在提交后）
- 当上游服务部署其最新更改时，我们的项目与上游微服务依赖项之间的不兼容性（由过渡环境中的QA测试人员检测到）
- 内测用户发现的错误报告，他们比起外部用户更先尝试新功能
- 由外部用户或媒体发现的错误或中断报告

*金丝雀*—或者先部署一小部分代码到生产环境—可以通过在全部代码部署到生产环境之前进行生产子集的初始反馈循环，来最大程度地减少生产环境中遇到的问题。但是，金丝雀也会引起问题，尤其是在一次部署多个版本时，部署之间的兼容性问题。这有时被称为*版本倾斜*, 这是分布式系统的一种状态，其中它包含代码，数据和配置的多个不兼容版本。就像我们在本书中讨论的许多问题一样，版本倾斜是一个挑战性的例子，当尝试随着时间的推移开发和管理软件时，可能会出现挑战性的问题。

*实验* 和 *特征标记* 是极其强大的反馈循环。它们通过隔离可在生产环境中动态切换的模块化组件中的更改来降低部署风险。高度依赖功能标记保护是持续交付的常见范例，我们将在第24章中进一步探讨。

### 访问和可行反馈

持续集成反馈能够广泛可访问也很重要。除了围绕代码可见性的开源文化之外，我们对测试报告的感受也类似。我们拥有一个统一的测试报告系统，在该系统中，任何人都可以轻松地查找构建或测试运行，包括所有日志（不包括用户个人身份信息），无论是针对单个工程师的本地运行还是在自动化开发或分阶段构建中。

除日志外，我们的测试报告系统还提供了有关构建或测试目标何时开始失败的详细历史记录，包括审核每次运行时切片的位置，运行的位置以及由谁进行的审核。我们还提供了切片分类系统，该系统使用统计信息在Google范围内对切片进行分类，因此工程师无需自己弄清楚这一点来确定他们的变更是否破坏了另一个项目的测试（如果测试是片状：可能不是）。

测试历史记录的可视性使工程师能够共享反馈并在反馈上进行协作，这是不同团队从系统之间的集成故障中诊断和学习的基本要求。同样，Google的错误（例如票证或问题）也会打开，其中包含完整的评论历史记录，供所有人查看和学习（客户除外）。

最后，来自持续集成测试的任何反馈不仅应该可以访问，而且应该可行-易于使用来查找和解决问题。在本章稍后的案例研究中，我们将看一个改善一个用户不友好反馈的示例。通过提高测试输出的可读性，您可以很容易理解反馈。

## 自动化

众所周知，从长远来看，自动化与开发相关的任务可以节省工程资源。直观地讲，由于我们通过将流程定义为代码来实现流程自动化，因此当签入更改时进行同行评审将减少出错的可能性。当然，像其他软件一样，自动化过程也会出现错误。但是，如果有效实施，与工程师手动尝试相比，它们仍然更快，更轻松，更可靠。

众所周知，从长远来看，自动化与开发相关的任务可以节省工程资源。直观地讲，由于我们通过将流程定义为代码来实现流程自动化，因此其他开发者对代码更新的检查将减少出错的可能性。当然，像其他软件一样，自动化过程也会出现错误。但是，如果有效实施，与工程师手动尝试相比，它们仍然更快，更轻松，更可靠。

持续集成特别是通过持续*构建*和持续*交付*来自动化构建和发布过程。整个过程都将进行连续测试，我们将在下一部分中进行介绍。和发布过程。整个过程都将进行连续测试，我们将在下一部分中进行介绍。

### 持续构建

*持续构建*（CB）可以立即集成最新的代码更改<sup>4</sup>，并运行自动化的构建和测试。由于CB既要运行测试又要构建代码，因此“破坏构建”或“失败构建”包括破坏测试和破坏编译。

提交代码更新后，持续构建应该运行所有相关测试。如果更改通过所有测试，则持续构建会将其标记为通过或“绿色”，因为它通常显示在用户界面（UI）中。此过程有效地在存储库中引入了两种不同的head版本：true head（已提交的最新更改）和green head（或持续构建已验证的最新更改）。工程师可以在其本地开发中同步到任一版本。通常需要与green head同步，以在稳定的环境下工作，并由持续构建进行验证，同时对更改进行编码，但其流程要求更改在提交前必须同步到true head的头上。

### 持续交付

持续交付（CD；第24章将更全面地讨论）的第一步是*发布自动化*，它将最新的代码和配置从head开始不断组合到候选发布中。在Google，大多数团队都以green head而不是true head来筛选它们。

> 候选发布（RC）：由一个自动过程创建的，可凝聚的，可部署的单元<sup>5</sup>，由经过连续构建的代码，配置和其他依赖项组成。

请注意，我们在候选版本中包括了配置——这是非常重要的，尽管随着候选版本的推出它在环境之间可能会略有不同。我们不一定要提倡将配置编译到您的二进制文件中——实际上，我们建议在许多情况下使用动态配置，例如实验或特征标记。<sup>6</sup>

相反，我们说的是，您应该将任何*设置*的静态配置提升为候选发布版本，以便它可以与相应的代码一起进行测试。请记住，大量的生产错误是由“愚蠢”的配置问题引起的，因此测试您的配置和代码一样重要（并与将使用它的相同代码*一起*进行测试）。版本倾斜通常发生在发行候选升级过程中。当然，这假定您的静态配置在版本控制中——在Google中，静态配置与代码一起在版本控制中，因此要经过相同的代码检查过程。

然后，我们将持续交付定义如下：

> 持续交付 (CD): 持续合并发布候选版本，然后在一系列环境中对这些候选版本进行升级和测试——有时达到生产状态要求，有时无法达到要求。

升级和部署过程通常取决于团队。我们将展示我们的案例研究如何引导这一过程。

对于希望从生产环境中的新变化（例如“持续部署”）获得持续反馈的Google团队，通常不建议将较大的整个二进制文件连续推送到green head。因此，通过实验或特征标记进行“选择性”连续部署是一种常见的策略。<sup>7</sup>

随着候选发布在环境中的发展，理想情况下，不应该重新编译或重建其组件（例如，二进制文件，容器）。从本地开发开始，使用诸如Docker之类的容器有助于增强环境之间候选发布的一致性。同样，使用Kubernetes之类的编排工具（在我们的情况下，通常是Borg）有助于实现部署之间的一致性。通过加强环境之间发布和部署的一致性，我们可以实现更高保真度的早期测试，并减少生产中的意外情况。

### 持续测试

让我们看一下在将连续测试（CT）应用于整个生命周期中的代码更新时，连续构建（CB）和连续发布（CD）如何配合，如图23-2所示。

![image-20210413200312251](/Users/xuhuan/Library/Application Support/typora-user-images/image-20210413200312251.png)

* 图23-2. 使用持续构建和持续发布的代码周期*

右箭头显示了从本地开发到生产环境的单个代码更新的进度。同样，我们在持续集成中的主要目标之一是确定在此过程中“什么时候进行测试” *“什么时候进行测试”。在本章的后面，我们将介绍不同的测试阶段，并提供一些有关在提交前与提交后以及在候选发布及以后版本中要测试什么的注意事项。我们将证明，当我们向右移动时，对代码的更改将经受逐渐扩大的范围的自动化测试。

### 为什么预提交是不充分的？

出于尽快发现有问题的更新的目的，以及能够在提交前运行自动测试的能力，你可能想知道：为什么不只在提交前运行所有测试？

主要原因是它太贵了。工程师的工作效率是非常宝贵的，在代码提交期间等待很长时间才能运行每个测试可能会造成严重破坏。此外，通过消除预提交的穷举性约束，如果测试通过的频率比失败的通过频率高得多，则可以大大提高效率。例如，可以将运行的测试限制在某些范围内，或者可以根据模型预测到一个失败的可能性来选择。

同样，对于工程师来说，代码更新时由于不稳定或脆弱等导致失败使工程师无法预提交，这是非常昂贵的。

另一个原因是，在我们运行提交前的测试以确认更新是安全的期间，基础仓库的更新方式可能与所测试的更新不兼容。也就是说，可能有两个更新涉及了完全不同的文件，从而导致测试失败。我们称这为空中相撞，虽然通常很少见，但在我们的规模中大多数情况下都会发生。用于较小仓库或项目的持续集成系统可以通过对提交进行序列化来避免此问题，使得我们正要测试的更新和完成测试的更新没有区别。

### 提交前和提交后的区别

因此，*应该*在提交前运行哪些测试？我们的一般经验法则是：只运行快速，可靠的规则。您可以在提交前接受某些范围的损失，但这意味着您需要在提交后发现遗漏的所有问题，并接受一定数量的回滚。提交后，只要您有适当的处理机制，你需要接受更长的时间和不稳定性来解决这些问题。

<img src="/Users/xuhuan/Library/Application Support/typora-user-images/image-20210415144551199.png" alt="image-20210415144551199" style="zoom:50%;float:left" />我们将在<span style="color:red">493页的“ Google的持续集成”</span>中展示TAP和我们的案例研究如何处理故障管理。





我们不想因为等待太慢的速度或太多的测试而浪费宝贵的工程师生产力，我们通常将提交前的测试限制为正在发生项目更新的测试。我们还同时运行测试，因此还需要考虑资源分配。最后，我们不想在提交前进行不可靠的测试，因此让许多工程师受其影响，因为让他们调试与他们的代码更新无关的相同问题的成本过高。

Google的大多数团队都会在提交前进行小型测试（例如单元测试）<sup>8</sup>——这些都是显而易见的，因为它们往往是最快，最可靠的。在预提交时是否以及如何运行更大范围的测试是一个更有趣的问题，并且因团队而异。对于想要运行它们的团队，密封测试是一种减少其固有不稳定性的行之有效的方法。另一个选择是允许大范围的测试在预提交时不可靠，但是在测试开始失败时主动禁用它们。

### 发布候选测试

在代码更新通过持续构建之后（如果发生故障，这可能需要花费多个周期），它将很快进入持续发布，并被包含在等待发布的候选版本中。

当持续发布建立候选发布时，它将对整个候选程序进行较大的测试。我们通过在一系列测试环境中对其进行升级并在每个部署中对其进行测试来测试候选版本。这可以包括沙盒，临时环境和共享测试环境（例如开发人员或过渡环境）的组合。



<hr>

1 *https://www.martinfowler.com/articles/continuousIntegration.html*

2 Forsgren, Nicole, et al. (2018). Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations. IT Revolution.

3 有时也被称为 “向左转移测试”

4 *Head* 是我们monorepo中最新的版本代码。在其他工作流程中，这也称为 *master*, *mainline*, 或 *trunk*。相应地，head合并也被称为 *基于trunk的开发*。

5  在Google中，发布自动化由与TAP不同的系统管理。 我们不会专注于*发布自动化如何组装候选发布*，但是，如果您有兴趣，我们会向您推荐*站点可靠性工程*（O'Reilly），我们在其中讨论了发布自动化技术（称为Rapid的系统）的详细过程。

6  带有实验和特征标记的持续发布将在第24章中进一步讨论。

7  我们将其称为“空中碰撞”是因为发生这种碰撞的可能性极低。但是，当确实发生这种情况时，结果可能会非常令人惊讶。

8 Google的每个团队都将其项目测试的子集配置为在提交前（而不是提交后）运行。实际上，我们的连续构建实际上优化了一些提交前的测试，这些测试可以在后台保存，以备提交后使用。我们将在本章稍后进一步讨论。